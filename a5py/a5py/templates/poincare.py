"""Poincare run templates.
"""
import numpy as np
import unyt

from a5py.ascot5io.marker  import Marker
from a5py.ascot5io.options import Opt
from a5py.physlib import parseunits

class PoincareTemplates():

    def marker_poincare(self, nmrk=100, rhomin=0, rhomax=1, tor=None,
                        pol=0*unyt.deg, time=0*unyt.s, pitch=1.0, species=None,
                        energy=None):
        """Generate markers at fixed intervals in radius.

        By default, the generated markers are field lines. Physical particles
        can be generated by passing marker species and mass.

        Parameters
        ----------
        nmrk : int, optional
            Number of markers.
        rhomin : float, optional
            Minimum marker initial rho coordinate.
        rhomax : float, optional
            Maximum marker initial rho coordinate.
        tor : float, optional
            Initial marker toroidal coordinate.

            If None, markers are distributed uniformly in toroidal direction.
        pol : float, optional
            Initial marker poloidal coordinate.

            If None, markers are distributed uniformly in poloidal direction.
        time : float
            Time slice at when field line markers are traced.

            If physical particles are traced, this is the time-instant at when
            the simulation begins.
        pitch : float
            Field line marker direction (1) co- (2) counter-parallel to
            the magnetic field lines.

            If physical particles are traced, this parameter is the guiding
            center pitch (ppar/p) instead.

        species : str, optional
            Marker species to be simulated instead of field lines.

            **IMPORTANT** The simulation mode also needs to be set to GO or GC.
        energy : float
            Marker energy if physical particles are traced.

        Raises
        ------
        ValueError
            If species is provided but not energy.
        """
        if species is not None and energy is None:
            raise ValueError("Please provide both species and energy")

        if tor is None:
            tor = 360 * np.random.rand(nmrk,) * unyt.deg
        else:
            tor = tor * np.ones((nmrk,))

        if pol is None:
            pol = 360 * np.random.rand(nmrk,) * unyt.deg
        else:
            pol = pol * np.ones((nmrk,))

        r = np.zeros((nmrk,))
        z = np.zeros((nmrk,))
        rhovals = np.linspace(rhomin, rhomax, nmrk)
        for i in range(nmrk):
            rz = self._ascot.input_rhotheta2rz(rhovals, pol[i], tor[i], time)
            r[i] = rz[0][i]
            z[i] = rz[1][i]

        if species is None:
            mrk = Marker.generate("fl", nmrk)
            mrk["r"][:]     = r
            mrk["z"][:]     = z
            mrk["phi"][:]   = tor
            mrk["pitch"][:] = pitch
            mrk["time"][:]  = time
            return ("fl", mrk)
        else:
            mrk = Marker.generate("gc", nmrk, species=species)
            mrk["r"][:]      = r
            mrk["z"][:]      = z
            mrk["phi"][:]    = tor
            mrk["pitch"][:]  = pitch
            mrk["time"][:]   = time
            mrk["energy"][:] = energy
            return ("gc", mrk)

    @parseunits(tor="deg", pol="deg")
    def options_poincare(self, simmode=4, tor=0*unyt.deg, pol=0*unyt.deg,
                         ntorb=500, nporb=500, both=False, maxrho=False,
                         mhd=False, cpulim=None):
        """Generate options to generate Poincar√© plot data.

        Collisionless orbits are traced for a fixed number of toroidal and
        poloidal transits. The points, where the given poloidal and toroidal
        planes were crossed, are recorded.

        Parameters
        ----------
        simmode : {1, 2, 4}, optional
            Simulation mode (1: gyro-orbit, 2: guiding-center, 4: field line).
        tor : array_like, optional
            Toroidal angle(s) where data is gathered for (R,z) plot(s).
        pol : array_like, optional
            Poloidal angle(s) where data is gathered for (rho,phi) plot(s).
        ntorb : int, optional
            Number of full toroidal orbits before simulation is terminated.
        nporb : int, optional
            Number of full poloidal orbits before simulation is terminated.
        both : bool, optional
            Both ``ntorb`` and ``nporb`` conditions must be met before
            simulation is terminated.
        maxrho : bool, optional
            Terminate marker when it escapes plasma.

            Otherwise the marker is terminated at the wall.
        mhd : bool, optional
            Set ``True`` to enable MHD.
        cpulim : float, optional
            Maximum CPU time spent on simulating a single marker.

            This parameter can be used to ensure the simulation is terminated.
        """
        out = Opt.get_default()
        out.update({
            "SIM_MODE":simmode,
            "ENABLE_ADAPTIVE":1,
            "ENABLE_ORBIT_FOLLOWING":1,
            "ENABLE_ORBITWRITE":1,
            "ORBITWRITE_MODE":0,
            "ORBITWRITE_TOROIDALANGLES":tor,
            "ORBITWRITE_POLOIDALANGLES":pol,
            "ORBITWRITE_NPOINT":nporb*pol.size + ntorb*tor.size,
            "ENDCOND_MAX_POLOIDALORBS":nporb,
            "ENDCOND_MAX_TOROIDALORBS":ntorb,
            "ENDCOND_MAXORBS":1,
            "ENDCOND_WALLHIT":1,
            "ENDCOND_MAX_RHO":1.0,
        })

        if both:
            out["ENDCOND_MAXORBS"] = 2
        if maxrho:
            out["ENDCOND_RHOLIM"] = 1
        if cpulim is not None:
            out["ENDCOND_CPUTIMELIM"]  = 1
            out["ENDCOND_MAX_CPUTIME"] = cpulim
        if mhd:
            out["ENABLE_MHD":mhd]

        return ("opt", out)
